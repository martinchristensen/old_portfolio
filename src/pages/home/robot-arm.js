/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, {useEffect, useRef, useState} from 'react'
import { useGLTF, useAnimations } from '@react-three/drei'
import {useFrame} from "@react-three/fiber";
import AboutBox from "./about-box";

export default function Model({ haveAboutBox , ...props}) {
  const group = useRef()
  const { nodes, materials } = useGLTF('/robot-arm.glb')

  const base = React.useRef();
  const lowerArm = React.useRef();
  const upperArm = React.useRef();

  const tcp = React.useRef();

  const claw1 = React.useRef();
  const claw2 = React.useRef();
  const claw3 = React.useRef();
  const claw4 = React.useRef();

  const [atAboutBox, setAtAboutBox] = useState(false);
  const [aboutCubeUp , setAboutCubeUp] = useState(false);

  const handleHaveAboutBox = () => {
    return haveAboutBox(true);
  }

  const baseAngle = () => {
    if (props.ray !== undefined) {
      const direction = props.ray['direction'];
      const x = direction['x'];
      // setBaseRot( -Math.PI/2 + Math.atan(x*6.25) / 2 )
      base.current.rotation.y = -Math.PI/2 + Math.atan(x*6.25) / 2;
    }
  }

  const lowerArmAngle = (y) => {
    if(0 < y) {
      if (y < 0.5) {
        return -Math.PI * Math.abs(y) / 8;
      }
      else {
        return -Math.PI * 0.5 / 8;
      }
    }
    else {
      return 0
    }
  }

  const upperArmAngle = (y) => {
    if (0.5 <= y) {
      return -Math.PI * Math.abs(y-0.5) / 4;
    }
    else {
      return 0
    }
  }

  const animateToAboutCube = () => {
    const cubeAtAngle = -2.1;
    if (!atAboutBox) {
      // Align base
      if (base.current.rotation.y < cubeAtAngle) {
        base.current.rotation.y += 0.005;
      }
      if (base.current.rotation.y > cubeAtAngle) {
        base.current.rotation.y -= 0.005;
      }
      // Go down
      if (lowerArm.current.rotation.z > -0.2) {
        lowerArm.current.rotation.z -= 0.01
      }
      if (upperArm.current.rotation.z < 0.65) {
        upperArm.current.rotation.z += 0.01
      }
      if (tcp.current.rotation.z > 0.98) {
        tcp.current.rotation.z -= 0.01;
      }
    }
  }

  const animateAboutCubeToScreen = () => {
    if (base.current.rotation.y < 0) {
      // Align base
      base.current.rotation.y += 0.00593;
      tcp.current.rotation.z -= 0.0134;
      upperArm.current.rotation.z -= 0.0225;
      lowerArm.current.rotation.z += 0.0225;
    }
  }

  const animateAboutCubeUp = () => {
    // Go up
    setAtAboutBox(true);
    if (upperArm.current.rotation.z > 0.3) {
      upperArm.current.rotation.z -= 0.01;
      tcp.current.rotation.z += 0.005;
      handleHaveAboutBox();
    }
    else if (aboutCubeUp === false) {
      setAboutCubeUp(true);
      animateAboutCubeToScreen();
    }
  }

  const animateGripper = () => {
    const speed = 0.03;
    if (props.hoverAbout) {
      if(claw1.current.rotation.y < 2)
      {
        claw1.current.rotation.y += speed;
        claw2.current.rotation.y += speed;
        claw3.current.rotation.y += speed;
        claw4.current.rotation.y -= speed;
      }
    }
    else if (1.44 < claw1.current.rotation.y) {
      claw1.current.rotation.y -= speed;
      claw2.current.rotation.y -= speed;
      claw3.current.rotation.y -= speed;
      claw4.current.rotation.y += speed;
    }
  }

  useFrame((state, {clock}) => {
    if (props.selected === null) {
      baseAngle();
      animateGripper();
    }
    else {
      animateToAboutCube();
      setTimeout(() => { animateAboutCubeUp() }, 1500)
    }
  });

  return (
    <group ref={group} {...props} dispose={null} castShadow={true}>
      <group castShadow={true}>
        <group rotation={[-Math.PI / 2, 0, 0]} castShadow={true}>
          <group castShadow={true}>
            <group rotation={[Math.PI / 2, 0, 0]} castShadow={true}>
              <group castShadow={true}>
                <group position={[0, 1.78, 0]} rotation={[0, 0, 0]} castShadow={true} ref={base}> {/*base*/}
                  <group position={[0.7, 2.68, 0.28]} rotation={[0, 0, 0]} castShadow={true} ref={lowerArm}> {/*firstJoint*/}
                    <group position={[-0.02, 6.15, -1.13]} rotation={[0, 0, 0]} castShadow={true} ref={upperArm}> {/*secondJoint*/}
                      {/*TCP z-DEFEAULT: Math.PI/2 */}
                      <group position={[-12.2, 2.01, 0.74]} rotation={[0, 0, Math.PI/2]} castShadow={true} ref={tcp}> {/*TCP*/}
                        <mesh scale={1} position={[-3.39, 1, 0]}>
                          <boxBufferGeometry args={[30, 0.1, 0.1]}/>
                          <meshBasicMaterial color={"#fd0404"} visible={false}/>
                        </mesh>
                        <AboutBox scale={3} position={[-5.68, 0.88, 0]} rotation={[0.525, 0.07, 0.12]} color={"#81da1c"} visible={atAboutBox} />
                        <group position={[-3.39, 1.77, 0]} rotation={[-1.57, 1.44, 0]} castShadow={true} ref={claw1}>
                          <mesh geometry={nodes.Object_22.geometry} material={nodes.Object_22.material}  castShadow={true} />
                          <mesh geometry={nodes.Object_23.geometry} material={nodes.Object_23.material} castShadow={true} />
                        </group>
                        <group position={[-3.38, 0.94, 0.83]} rotation={[-0.02, 1.44, 0.02]} castShadow={true} ref={claw2}>
                          <mesh geometry={nodes.Object_25.geometry} material={nodes.Object_25.material} castShadow={true} />
                          <mesh geometry={nodes.Object_26.geometry} material={nodes.Object_26.material} castShadow={true} />
                        </group>
                        <group position={[-3.38, 0.11, -0.01]} rotation={[1.57, 1.44, 0]} castShadow={true} ref={claw3}>
                          <mesh geometry={nodes.Object_28.geometry} material={nodes.Object_28.material} castShadow={true} />
                          <mesh geometry={nodes.Object_29.geometry} material={nodes.Object_29.material} castShadow={true} />
                        </group>
                        <group position={[-3.33, 0.95, -0.81]} rotation={[0, 0, -1.57]} castShadow={true} ref={claw4}>
                          <mesh geometry={nodes.Object_31.geometry} material={nodes.Object_31.material} castShadow={true} />
                          <mesh geometry={nodes.Object_32.geometry} material={nodes.Object_32.material} castShadow={true} />
                        </group>
                        <group position={[-2.98, 0.95, 0]} rotation={[0, 0, -1.57]} castShadow={true}/>
                        <mesh geometry={nodes.Object_16.geometry} material={nodes.Object_16.material} castShadow={true}/>
                        <mesh geometry={nodes.Object_17.geometry} material={materials.copper} castShadow={true}/>
                        <mesh geometry={nodes.Object_19.geometry} material={materials.grey} castShadow={true}/>
                        <mesh geometry={nodes.Object_18.geometry} material={materials.ivory_gripper} castShadow={true}/>
                      </group>
                      <mesh geometry={nodes.Object_14.geometry} material={materials.ivory} castShadow={true}/>
                    </group>
                    <mesh geometry={nodes.Object_12.geometry} material={materials['ivory_arm.001']} castShadow={true}/>
                  </group>
                  <mesh geometry={nodes.Object_10.geometry} material={materials.grey_rotation} castShadow={true}/>
                </group>
                <mesh geometry={nodes.Object_6.geometry} material={nodes.Object_6.material} castShadow={true} />
                <mesh geometry={nodes.Object_7.geometry} material={nodes.Object_7.material} castShadow={true}/>
                <mesh geometry={nodes.Object_8.geometry} material={materials.grey_base} castShadow={true}/>
              </group>
              <group />
            </group>
          </group>
        </group>
      </group>
    </group>
  )
}

useGLTF.preload('/robot-arm.glb')
